\section{Listas}
\begin{frame}

    \frametitle{Listas}

   \begin{block}{}
     \begin{itemize}
      \item Requisito: conceitos de recursividade e functores dominados!
      \item  Os  conceitos são os próximos os das  LPs convencionais
     \item Essencialmente vamos computar sob uma árvore
         binária (cada nó tem duas ramificações)

      \item Lembrando que uma estrutura binária de árvore tem uma
      equivalência com uma árvore n-ária (ver livro de Estrutura de Dados)

      
      \item Logo,  listas são estruturas flexíveis e poderosas!

    \end{itemize}
    
    \end{block}
    
\end{frame}


\begin{frame}
 % \frametitle{Fluxo do Cálculo Recursivo}
\frametitle{Ilustrando uma Lista em Formato Binário}

\begin{figure}[!htb]
\centering
\includegraphics[width=.7\textwidth, height=0.650\textheight]{figures/ilustra-lista-01.jpg}
%\label{fig_ilustra_arv}
\caption{Uma estrutura  Lista -- Homogênea}
\end{figure}

\end{frame}


\begin{frame}
  \frametitle{Ilustrando a Listas}
\begin{figure}[!htb]
\centering
\includegraphics[width=.7\textwidth, height=0.650\textheight]{figures/ilustra-lista-02.jpg}
%\label{fig_arv_recurs_2}
\caption{Listas são inerentemente \textbf{recursivas}!}
\end{figure}
\end{frame}



\begin{frame}
 \frametitle{Exemplificando as Listas}
\begin{figure}[!htb]
\centering
\includegraphics[width=.7\textwidth, height=0.650\textheight]{figures/exemplo_listas_01.jpg}
%\label{fig_arv_recurs_2}
%\caption{Fluxo Recursivo 2}
\end{figure}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, allowframebreaks=0.9]
 \frametitle{Sintaxe das Listas}


\begin{block}{Definições iniciais (e recursivas)}
\begin{itemize}


\item Uma lista é uma sequência de objetos;

\item Uma lista é uma estrutura de dados que representa
uma coleção de objetos homogêneos;

\item Uma lista  apresenta uma hierarquia natural, internamente,
em \textit{cabeça} de lista e sub-lista, até o fim da lista.

\end{itemize}
\end{block}
%\lbrack       left bracket [
%\rbrack       right bracket ]

\framebreak
\begin{block}{Notação:}
\begin{itemize}
   \item O símbolo ``\lbrack'' é usado para descrever o início de uma lista,
e ``\rbrack'' para o final da mesma;

   \item Exemplo: seja a lista \lbrack a, b, c, d \rbrack,  logo um predicado cujo
argumento seja algumas letras,  tem-se uma lista do tipo:\\
  \begin{itemize}
  \item letras(\lbrack  a, b, c, d \rbrack )
 \item Onde `a' é  o   \textit{cabeça} (primeiro elemento) da lista
 \item e \lbrack b, c, d \rbrack é uma \textit{sub-lista} que é uma lista!
  \end{itemize}

\item Os elementos de uma lista são lidos da esquerda para direita;

\item  A ``{\em sub-lista}'' \lbrack b,  c, d \rbrack é conhecida como  \textit{resto} ou ``{\em cauda}'' da lista;
        
\item   Esta sub-lista é uma lista, e toda definição segue-se recursivamente.
 \end{itemize} 

\end{block}


\framebreak
\begin{block}{Operador ``{\bf |}'':}

\begin{itemize}
  \item ``{\em  Como vamos distinguir de onde se encontra
a cabeça  da cauda da lista?}'' 

  \item Com as listas novos símbolos foram introduzidos, 
isto é, além dos delimitadores \lbrack \ldots \rbrack, há um 
 novo operador que \textbf{separa} 
 ou \textbf{define} quem é a elemento cabeça da lista e  cauda. 

  \item Este operador é conhecido como
 ``{\em pipe}'' (ou \textit{barra vertical}), simbolizado por ``{\bf |}'', que 
 separa  o lado esquerdo  da direita da lista. 
 
  \item  Esta separação  é necessário para se realizar os 
  \textit{casamentos de padrões} nas linguagens lógicas.

\end{itemize}
\end{block}

\framebreak
\begin{block}{Exemplos de ``{\em casamentos}'':}

% Os exemplos abaixo  ilustram
%como funcionam os casamentos entre variáveis, átomos, etc em listas.
% Atenção em cada exemplo e faça suas próprias conclusões 
%[ de como as listas funcionam.
%\end{itemize}
\begin{small}
\begin{verbatim}
 [ a, b, c, d ] = X
 [ X | b, c, d ]  =  [ a, b, c, d ]
 [ a | b, c, d ]  =  [ a, b, c, d ]
 [ a , b | c, d ]  =  [ a, b, c, d ]
 [ a , b , c | d ]  =  [ a, b, c, d ]
 [ a , b , c , d | [] ]  =  [ a, b, c, d ]
 [] = X
 [ [ a | b , c , d] ] = [ [ a , b , c , d ] ]
 [  a | b , c , [ d ] ] = [  a , b , c , [ d ] ]
 [  _ | b , c , [d ] ] = [  a , b , c , [ d ] ]
 [  a | Y ] = [  a , b , c ,  d ]
 [  a | _ ] = [  a , b , c ,  d ]
 [  a , b | c , d ] = [  X , Y | Z ]
 \end{verbatim}
\end{small}
\end{block}

\framebreak
\begin{block}{Contra-exemplos de ``{\em casamentos}'':}

\begin{verbatim}
 [ a , b | [c, d] ]  !=  [ a, b, c, d ]
 [ [ a , b , c , d] ]  !=  [ a, b, c, d ]
 [  a , b , [ c ] , d, e ]  !=  [ a, b, c, d, e ]
 [ [ [ a ] | b , c , d] ] != [ [ a , b , c , d] ]
 \end{verbatim}

\end{block}

\framebreak
\begin{itemize}
  \item Estes  casamentos de objetos de uma lista
  são também conhecidos  por ``{\em matching}'' 

\item  Devido ao fato de listas modelarem
qualquer estrutura de dados, invariavelmente, seu uso  é extensivo
há  problemas em geral (dos simples a complexos)

\end{itemize}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile, allowframebreaks=0.9]
\frametitle{Exemplo: encontrar o comprimento de uma lista}
 
\begin{itemize}
   \item O comprimento de uma lista é o comprimento de sua \textbf{sub-lista}, mais \textbf{um}
   \item O comprimento de uma lista vazia (\lbrack  \rbrack) é zero.
 \end{itemize} 
 
Em Picat, este enunciado é escrito por:

\begin{verbatim}
REFAZER

#1 compto([ ], 0).
#2 compto([X | T], N) => compto(T, N1), N is N1+1.

? - compto([a, b, c, d], X).
X = 4
\end{verbatim}


\framebreak
Um ``{\em mapa de memória}'' é dado por:

\begin{center}
\begin{tabular}[c]{|c|c|c|c|c|c|}
\hline
& Regra & X & T & N1 & N = N+1\\\hline
compto([a,b,c,d],N) & \#2 & a & [b,c,d] & 3 $\rightarrow$ & 3+1$=$4\\\hline
compto([b,c,d],N) & \#2 & b & [c,d] & 2 $\rightarrow$ & $\nwarrow$ 2+1\\\hline
compto([c,d],N) & \#2 & c & [d] & 1 $\rightarrow$ & $\nwarrow$ 1+1\\\hline
compto([d],N) & \#2 & d & [] & 0 $\rightarrow$ & $\nwarrow$ 0+1\\\hline
compto([],N) & \#1 & -- & -- & -- & $\nwarrow$ 0\\\hline
\end{tabular}
\end{center}
 

\end{frame}


\begin{frame}[fragile, allowframebreaks=0.9]
\frametitle{Exemplo: verificar a pertinência de um objeto na lista}

Verifica se um dado objeto pertence há uma  lista
 \begin{verbatim}
REFAZER
member( H, [ H |  _ ] ).
member( H, [ _  | T ] ) :- member(H, T).
\end{verbatim}

O interessante é observar a versatilidade 
deste  predicado em várias situações:
\begin{verbatim}
?- member(3, [4,5,3]).

Yes
?- member(X, [4,5,3]).
X = 4 ;
X = 5 ;
X = 3 ;
No
?- member(3, X).
X = [3|_G231] 
Yes
?- member(3, X).

X = [3|_G231] ;
X = [_G230, 3|_G234] ;
X = [_G230, _G233, 3|_G237] 
.........................
\end{verbatim}


\end{frame}



\begin{frame}[fragile, allowframebreaks=0.9]
\frametitle{Exemplo: adicionar um elemento  em uma lista}

Um objeto é adicionado a lista
sem repeti\c{c}ão caso este já
 esteja contido na lista:
 
\begin{verbatim}
REFAZER
add_to_set(X, [ ], [X]).
add_to_set(X, Y, Y) :- member(X, Y).
add_to_set(X, Y, [X | Y]).
\end{verbatim}

\end{frame}


\begin{frame}[fragile]
\frametitle{Concluindo Listas}

\begin{block}{}
\begin{itemize}
  \item Há muitos predicados e funções prontas sobre listas no módulo lists.pi (conferir)
  \item Se aprende sobre listas, fazendo muitos métodos
  \item A recursividade em sua modelagem, define a metodologia de se \textit{programar em lógica}
  \item Exercitar-se
  \item Usar as listas em problemas complexos, como na aula de aplicações de buscas.
  
\end{itemize}

\end{block}

\end{frame}














