%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Recursão}

\subsection{Recursão}
\begin{frame}[fragile]

\frametitle{Recursão}

\begin{itemize}

    \item A \textit{recursão} é um importante conceito da matemática e presente em muitas  linguagens
    de programação. Exemplo: LISP, Haskell, etc

    \pause
    \item Permite expressar conceitos complexos em uma sintaxe abstrata, mas  simples de ler.
    \pause
    \item Uma regra é dita recursiva quando ela faz auto-referência.
    
    \pause
    \item Em Picat, a recursão pode ser usada sob uma notação em \textit{lógica} ou \textit{funcional}
    
    \pause
    \item A funcional apresenta muita clareza ao código!
\end{itemize}

%\pause
%\centering
%\includegraphics[scale=0.5]{figures/Recursao.png}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Conceitos Matemáticos com Recursividade -- I}

\begin{block}{Somatório dos $N$ naturais}

 O somatório dos \emph{n}  primeiros  números naturais é recursivamente 
 definido como a soma de todos \emph{n-1} números, mais o termo \emph{n}. 
 Ou seja:

    \[
    S(n)=\left \{
    \begin{tabular}
        [c]{ll}
        $1$ & para $n=1$ \\
        $S(n-1) + n $ & para $n \geqslant 2$ e $n \in \mathbb{N}$
    \end{tabular}
    \right.
    \]
    
    Ou seja:
    
    \[
    S(n)=
    \begin{tabular}[c]{cc}
        $\underbrace{1+2+3+.....+(n-1)}$ &  $  + n$\\
        $S(n-1)$ &
    \end{tabular}
    \]
\end{block}            

\end{frame}

\begin{frame}[fragile]
\frametitle{Conceitos Matemáticos com Recursividade -- II}


\begin{block}{Fatorial}

O Fatorial de um número $n$ é definido  recursivamente pela
 multiplicação do fatorial do termo $n-1$ por $n$. 
  O fatorial só pode ser calculado para números positivos. 
  Adicionalmente, o fatorial de $0$ é igual a 
  $1$ por definição.
      
    \[ 
    Fat(n)=\left\{
    \begin{tabular}[c]{ll}%
        $1$ & para $n = 0$\\
        $Fat(n-1) . n$ & para $n\geqslant1$ e $n \in \mathbb{N}$
    \end{tabular}
    \right.
    \]
    
    \vskip 11pt
    Portanto:
    \vskip 11pt
    
    \[
    Fat(n)=
    \begin{tabular}
        [c]{cc}%
        $\underbrace{1\ast2\ast3 . ..... . (n-1)}$ & $ .  \ n$\\
        $Fat(n-1)$ &
    \end{tabular}
    \]

\end{block}    
\end{frame}


\begin{frame}[fragile]
\frametitle{Conceitos Matemáticos com Recursividade -- III}

\begin{block}{Sequência Fibonacci}

A sequência Fibonacci é uma sequência de números calculada a partir da soma dos
dois últimos números anteriores desta. Ou seja o $n-esimo$ termo da Sequência Fibonacci é definido como a soma dos termos $n-1$ e $n-2$. Como fato ou definição: os dois primeiros termos, $n = 0$ e $n = 1$, são respectivamente, $0$ e $1$.
      
      \[
      Fib(n)=\left\{
      \begin{tabular}[c]{ll}%
          $0$ & para $n = 0$\\
          $1$ & para $n = 1$\\
          $Fib(n-1) + Fib(n-2)$ & para $n\geqslant1$ e $n \in \mathbb{N}$
      \end{tabular}
      \right.
      \]
 
\end{block}    
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]

\frametitle{Conceitos Matemáticos com Recursividade -- IV}

  \begin{itemize}
      
      \item Podemos perceber algo em comum entre estas três regras, todas tem uma ou mais
      condições que sempre tem o mesmo valor de retorno, ou seja, todas tem uma \textit{regra de  aterramento}.
      
      \item Uma condição de \textit{aterramento} é uma condição onde a chamada recursiva da regra
      acaba (pára ou termina).
      
      \item Caso uma regra não tenha uma regra de aterramento, poderá ocorrer uma recursão infinita deste regra, ou seja, são feitas infinitas chamadas recursivas
      da regra.
  \end{itemize}

\end{frame}


\begin{frame}[fragile]

\frametitle{Exemplos}

Numa visão funcional, estas regras matemáticas podem ser transcritas em Picat como:

    \begin{lstlisting}[frame=single]
fatorial(0) = 1.
fatorial(1) = 1.
fatorial(n) = n * fatorial(n-1).
    \end{lstlisting}

    \begin{lstlisting}[frame=single]
fibonacci(0) = 0.
fibonacci(1) = 1.
fibonacci(n) = fibonacci(n-1) + fibonacci(n-2).
    \end{lstlisting}

    \begin{lstlisting}[frame=single]
somatorio(0) = 0.
somatorio(1) = 1.
somatorio(n) = n + somatorio(n-1).
    \end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Recursão Infinita}

    \begin{itemize}
        \item Caso alterássemos a definição da regra fatorial de modo que ela seja:
        
        \[
        Fat(n)= 
        \begin{tabular}[c]{ll}
            $Fat(n-1)\ast n$, &$\forall n \in \mathbb{N}$ ou $\forall n \geq 0$
        \end{tabular}
        \]
        
        \item Teríamos um caso de recursão infinita, pois a regra Fatorial seria continuamente
        chamada até que $n < 0$, nesse caso haveria um erro, pois estaria tentando executar algo indefinido.
        
    \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{Exercício}

Para os exemplos anteriores, reescreva
estas formulações sob uma visão
lógica e  procedural.

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\textit{Backtracking}}
\begin{frame}[fragile]

\frametitle{\textit{Backtracking}}

 O que distingue uma regra em realizarr \textit{backtracking} ou não, é o uso do símbolo
        \verb!?=>! no escopo da regra.
        
O procedimento do \textit{Backtracking} é definido por:
    \begin{enumerate}
        
        \item O casamento de um predicado \textit{backtrackable} $p$ com outro predicado \textit{backtrackable} $p1$.
        
        \item A execução do predicado $p$.
        
        \item Caso ocorra uma falha durante a execução do predicado $p$ o compilador irá reinstanciar todas as variáveis de 
        $p$, incluindo aquelas que são indexadas a partir de um domínio, com a única exceção sendo variáveis instanciadas a
        partir de argumentos do predicado.
        
        \item O predicado será executado novamente.
        
        \item Este processo se repete até não for mais possível a reinstanciação de variáveis, ou ocorrer um erro durante a
        execução.
\end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

\frametitle{Exemplos}
    
Tomando como exemplo uma relação de parentesco, como a seguinte:
% usar antecendente,sucessor, descendente etc.
        \begin{lstlisting}[frame=single]
index(-,-) (+,-) (-,+)
antecedente(ana,maria).
antecedente(pedro,maria).
antecedente(maria,paula).
antecedente(paula,lucas).
antecedente(lucas, eduarda).

index(-)
mulher(ana).
mulher(maria).
mulher(paula).
mulher(eduarda).
homem(pedro).
homem(lucas).

mae(X,Y) ?=> antecedente(X,Y), mulher(X).
pai(X,Y) ?=> antecedente(X,Y), homem(X).
avos(X,Y) ?=> antecedente(X,Z), antecedente(Z,Y).
sucessor(X,Y) ?=> antecedente(Y,X).
sucessor(X,Y) ?=> antecedente(Y,Z), sucessor(X,Z).
        \end{lstlisting}
    
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{}
    
    \begin{itemize}
        \item Uma chamada do tipo $mae(maria, X)$, seria como perguntar ao compilador
        "Maria é mãe de quem ?".
        
        \item Nesse caso o compilador iria testar cada possível valor que pudesse ser 
        unificado com $X$ que pudesse satisfazer a regra $mae(maria,X)$.
        
        \item Ou seja, seria como se estivéssemos perguntando:
        
        \begin{itemize}
            \item "Maria é mãe de Ana ?".
            
            \item "Maria é mãe de Paula ?".
            
            \item "Maria é mãe de Pedro ?".
            
            $\vdots$
        \end{itemize}
        
    \end{itemize}
    
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
