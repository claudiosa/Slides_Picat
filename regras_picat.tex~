%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Predicados e Funções}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Predicados e Funções}
\begin{minipage}{0.47\textwidth}
    \begin{itemize}
        \item Definições
        \item Predicados ou Cláusulas
        \item Funções 
        \item Contexto de uso
        \item Exemplos        
    \end{itemize}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{figure}[ht!]
\begin{center}
\includegraphics[width=1.2\textwidth, height=0.40\textheight]{figures/logo_picat_alex.jpg}
\end{center}
\end{figure}
\end{minipage}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile,allowframebreaks=0.8,c]
	\frametitle{Predicados e Funções}
    
\begin{itemize}

\item Os \textbf{predicados} sempre assumem valores valores lógicos \texttt{true} ($1$) ou \texttt{false} ($0$).

\item Os \textbf{predicados} em seus argumentos, podem passar $n$-termos e receber
outros $m$-termos.

\item Quanto as \textbf{funções}, estas funcionam seguindo as regras de funções matemáticas,
sempre retornando um único valor. Logo, um tipo particular de \textbf{predicados lógicos}
que podem retornar vários termos

\item Predicados e funções são definidos com regras de \textit{casamento de padrões}

\item Predicados são conhecidos como \textbf{regras lógicas}, há dois tipos de regras:
\framebreak        
        \begin{itemize}
            \item Regras \textbf{sem} {\em backtracking} (\textit{non-backtrackable}):
        	
            \begin{tabbing}
              aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
             \> \> \verb+ Cabeça , Condicional + \textbf{\textcolor{red}{=>}} \verb+ Corpo .+
            \end{tabbing}
            

            \item Regras \textbf{com} {\em backtracking}:
            
            \begin{tabbing}
              aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
             \> \> \verb+ Cabeça , Condicional + \textbf{\textcolor{red}{?=>}} \verb+ Corpo .+
            \end{tabbing}
        
        \end{itemize}
\framebreak        
       
  \item A identificação da sintaxe é dada por:
  
  \begin{itemize}
  
      \item \emph{Cabeça}: indica um padrão de regra a ser casada.
      
      Forma geral:
      \begin{tabbing}
          aa \= aaa \= aaa \= aaa \kill
          \> \> $regra(termo_1, \ldots,termo_n)$
      \end{tabbing}
      
      Onde:
      
      \begin{itemize}
          \item \emph{regra} é um átomo que define o nome da regra.
          \item \emph{n} é a aridade da regra (\emph{i.e.} o total de argumentos)
          \item Cada \emph{$termo_i$} é um argumento da regra.
      \end{itemize}
      
      \item \emph{Cond}: é uma ou várias condições sobre a execução desta regra.
          
      \item \emph{Corpo}: define as ações da regra 
      
  \end{itemize}
  
  \item Todas as regras são finalizadas por um ponto final (.), seguido por um espaço 
  em branco ou nova linha.
  
  \item Ao longo dos exemplos, detalhes a mais sobre esta construção de \textbf{predicados} e \textbf{funções}
      
\end{itemize}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]
	\frametitle{Regras com e sem Backtracking -- Exemplo}


\begin{footnotesize}
\begin{verbatim}
main => regra_01(7)  ,
        regra_01(-4) ,
        regra_01(44) .
        
regra_01(0)          ?=> printf("\n  CHEGOU A 0 !!!\n").
regra_01(N) , N < 0  ?=> printf("\n  EH UM NEGATIVO !!!\n").
regra_01(N) , N > 10 ?=> printf("\n  EH MAIOR QUE 10 !!!\n").
regra_01(N) , N <= 10  =>  
          printf("\t :%d ", N),
          regra_01(N-1).

%% =<  EH IGUAL a >= :: sobrecarga
%%% $ picat regras_com_sem_backtraking.pi

\end{verbatim}

\end{footnotesize}
\textcolor{red}{Há uma recursão aqui. Algumas seções a frente.}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Casamento de Padrões}

\begin{frame}[fragile]
\frametitle{Casamento de Padrões}

\begin{itemize}

\item O algoritmo de {\em casamento de padrões} para regras é análogo ao algoritmo de    unificação para variáveis. 

\item O objetivo é encontrar dois padrões que possam ser unificados para se inferir alguma ação.

\pause
\item Muitos exemplos no curso

\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Casamento de Padrões -- Procedimento}


Procedimento de {\em casamento de padrões}:

\begin{itemize}
	\item Dado um padrão $p_1(t_1, \ldots,t_m)$, este \emph{casa} 
	com um padrão semelhante $p_2(u_1, \ldots,u_n)$ se:
    
    \begin{itemize}
    	\item $p_1$ e $p_2$ forem átomos equivalentes;
    
        \item O número de termos (chamado de aridade) em ($t_1, \ldots,t_m$)
        e ($u_1, \ldots,u_n$) for equivalente.
    
    	\item Os termos ($t_1, \ldots,t_m$) e ($u_1, \ldots,u_n$) são equivalentes, ou 
    	tornaram-se  equivalentes pela unificação de variáveis	em qualquer um dos dois termos;
    \end{itemize}
    
    \item Caso essas condições forem satisfeitas, o padrão $p_1(t_1,\ldots,t_m)$  casa com o padrão $p_2(u_1, \ldots,u_n)$.
    
\end{itemize}        

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \begin{frame}[fragile]
%     
% \begin{block}{Exemplos de \textit{casamento}}
%
%  
% \end{block}
%     
% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]

	\frametitle{Metas ou Provas -- (\textit{goals})}
	
	\begin{itemize}
	    
	 \item Na matemática ao se deduzir um valor de um teorema, tem-se uma \textit{prova}. 
	  Assim, o termo  \textit{goal}  é conhecido também como \textit{prova do programa}
	 
	 \pause
	    \item Metas ou provas (do inglês: \textit{goal}) são estados que definem o final da execução
	    
  	 \pause
	    \item Uma meta pode ser, um valor lógico, uma chamada de outra regra, 
	    uma exceção ou uma operação lógica, um termo ...

  	 \pause
	    \item Exemplo: a cláusula \texttt{main} é uma meta a ser provada!

  	 \pause
	    \item Em resumo, todas cláusulas, de alguma maneira são metas a serem provadas!

	\end{itemize}



\end{frame}
    
  %  \begin{enumerate}
  %      \item \texttt{true, yes} $\Rightarrow$ Valor lógico para verdade.
%   %      \item \texttt{false, no} $\Rightarrow$ Valor lógico para falsidade.
%         \item \texttt{$p(t_1,\ldots,t_n)$} $\Rightarrow$ Chamada de uma regra \emph{p}.
%         \item \texttt{(P,Q), (P;Q), (P\&\&Q), (P||Q), not P} $\Rightarrow$ Operação lógica 
%     %    sobre uma ou mais metas P e Q.
   % \end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Funções}

\begin{frame}[fragile]
	\frametitle{Funções -- I}
    
    \begin{itemize}
        \item A forma geral de uma função é:
        
        \begin{tabbing}
          aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
          \> \> $Cabe$ç$a = X \ $\verb+=>+$\ Corpo$. 
        \end{tabbing}

       \pause        
        \item Caso tenhamos uma condição \emph{Cond}::
        
        \begin{tabbing}
          aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
          \> \> $Cabe$ç$a = X , Cond \ $\verb+=>+$\ Corpo$. 
        \end{tabbing}
        
        \item \textcolor{red}{Funções \textbf{não} admitem \textbf{\textit{backtracking}}}.
    \end{itemize}
\end{frame}
    
\begin{frame}[fragile]
	\frametitle{Funções -- II}

    
    \begin{itemize}
        \item Funções são tipos especiais de regras que sempre sucedem com \emph{uma} 
        resposta.
        
        \pause
        \item Funções em Picat tem como intuito serem sintaticamente semelhantes a funções matemáticas (vide \emph{Haskell}).
        
        \pause
        \item Em uma função a \emph{Cabeça} é uma equação do tipo $f(t_1,\ldots,t_n)=X$, onde
        \emph{f} é um átomo que é o nome da função, \emph{n} é a aridade da função, e cada
        termo $t_i$ é um argumento da função.
        
        \item \emph{X} é uma expressão que é o retorno da função.
        
    \end{itemize}
    
\end{frame}
    
\begin{frame}[fragile]
	\frametitle{Funções  -- III}
    
    \begin{itemize}
    
        \item Funções também podem ser denotadas como fatos, onde podem servir como 
        \textbf{\textit{aterramento}} para regras recursivas.
        %, ou até mesmo como versões simplificadas de uma      regra. 
        
        
        \item Esta são denotadas como: $f(t_1,\ldots,t_n) = $ \emph{Expressão}, onde \textit{Expressão}
        pode ser um valor ou uma série de ações.
        
    \end{itemize}
    
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Regras, Metas e Funções -- Exemplo}

\begin{footnotesize}
\begin{verbatim}
main =>
       X = 3, 
       Y = 4,
       um_predicado(X,Y,Z),
       R = uma_funcao(X,Y),
       printf("\n Z: %d \t R: %d", Z, R),
       println("\n FIM"). 
       
um_predicado(X,Y,Z) => Z = X + Y.

uma_funcao(X,Y) = R => R = X + Y.
\end{verbatim}

\end{footnotesize}
\end{frame}


\begin{frame} [fragile]

\frametitle{Regras, Metas e Funções -- Exemplo}
\begin{footnotesize}
\begin{verbatim}
Picat> cl('predicados_funcoes').
Compiling:: predicados_funcoes.pi
predicados_funcoes.pi compiled in 0 milliseconds
loading...

yes

Picat> um_predicado(3,4,Z), write(Z).
7Z = 7
yes

Picat> uma_funcao(3,4) = R, write(R).
7R = 7
yes

Picat>
\end{verbatim}
\end{footnotesize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Relembrando as Regras}
\begin{frame}[c, fragile, allowframebreaks=0.75]
	\frametitle{Relembrando as Regras}
    
    \begin{itemize}
        \item Forma geral de um predicado do tipo Regra:
    
        \begin{tabbing}
          aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
          \> \> \verb+ Cabeça , Condicional  =>   Corpo .+ 
        \end{tabbing}
        
        \item  Forma geral de um predicado com \textit{backtracking}:
        
        \begin{tabbing}
          aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
            \> \> \verb+ Cabeça , Condicional + \textbf{\textcolor{red}{?=>}} \verb+ Corpo .+
        \end{tabbing}
    \end{itemize}
    
    \textcolor{red}{Em Prolog, esta condicional (Cond) entra no corpo da regra. Picat é flexível!}

    \framebreak
    
    \begin{itemize}
        \framebreak
        
        \item Dentro de uma regra, \emph{Cond} só pode ser avaliado uma vez, acessando somente termos dentro do escopo do predicado.
        
        \item Sempre estar atento que: regras são \textbf{sempre avaliados com valores lógicos} ({\em true} ou {\em false})
        
        \item Por outro lado, as variáveis  como argumento ou  instanciadas
        dentro dele, podem ser utilizadas dentro do escopo da regra, 
        ou no escopo onde  esta regra foi chamada.
    \end{itemize}
    
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Regras do Tipo  Fatos}
\begin{frame}[c,allowframebreaks=0.6,fragile]
\frametitle{Regras do Tipo  Fatos}

    \begin{itemize}
        \item As regras que não tem condicionais e nem corpo, estes  são conhecidos
        como:  \textit{fatos} ou \textit{regras sem-corpo}
        
       \item Estes \textit{fatos} são regras \textit{sempre verdadeiras}
        
        \item Formato dos fatos são do tipo:
        
        \begin{tabbing}
          aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
          \> \> $p(t_1,\ldots,t_n)$. 
        \end{tabbing}
        
        \item Os argumentos de um \emph{fato} \textbf{não} podem conter \textbf{variáveis}.
        
        \framebreak
        
        \item A declaração de um fato é precedida por uma declaração \textbf{\emph{index}},
        algo como:
        
        \begin{tabbing}
        aa \= aaa \= aaa \= aaa \= aaa \= aaa \= aaa \kill
            \> \texttt{index ($M_{11},M_{12},\ldots,M_{1n}$) $\ldots$ ($M_{m1},M_{m2},\ldots,M_{mn}$)}\index{\texttt{index}} 
        \end{tabbing}
        
        \item Onde um $M_{ij}$ com o simbolo `$+$',  significa que este termo já foi 
        indexado.
        
        \item Quanto o `$-$' significa que este termo deve ser indexado
        
        \item Ou seja, quando ocorre um simbolo `$+$' em um grupo do \textit{index}, é avaliado
        pelo compilador como um valor constante a ser casada
        
        %, que não irá gerar uma nova regra durante
        %a execução do programa.
        
        \item Quanto ao `$-$', este é avaliado pelo compilador com uma variável que deverá ser 
        instanciada à um valor. Ou seja, quando se deseja unificar um valor a esta variável
        
        \item Dica: o parâmetro `$-$' no \textit{index} é quase como regra geral
                
        \item \textbf{Não} pode haver um \textbf{predicado} e um \textbf{predicado 
        fato} com \textbf{mesmo nome}.
        
    \end{itemize}
\end{frame}



\begin{frame} [fragile]
\frametitle{Exemplo -- Função e Regras}

\begin{footnotesize}
\begin{verbatim}
index (+,+,+) (+,+, -) (-,+,-) (-,-,+) (-,-, +) 
      (+,-,+) (+,+,-)  (-,-,-)
%(-,-,-) %% NENHUM argumento instanciao -- UTIL
%(+,+,+) %% TODOS ARGUMENTOS DEVEM ESTAR INSTANCIADOS
%(+,+, -) (-,+,-) (-,-,+) (-,-, +) (+,-,+) (+,+,-) (-,-,-)

and2(true,true,true).
and2(true,false,false).
and2(false,true,false).
and2(false,false,false).

main ?=>
       and2(X,Y,Z), % and eh reservado
       printf("\n X: %w \t Y: %w \t Z: %w", X, Y, Z),
       fail.
main =>       
       println("\n FIM"). 
\end{verbatim}
\end{footnotesize}

\textcolor{red}{Este exemplo é muito interessante. Execute ele na console do interpretador
excluindo alguns dos parâmetros do \textit{index}}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Exemplos}

\begin{frame}[fragile]

\frametitle{Exemplos}

\begin{block}{Exemplo de Predicado ou regra}
   
\begin{lstlisting}[frame=single]
contas_P0(X1, X2, X3, Z) ?=>
    number(X1),
    number(X2),
    number(X3),
    X1 < X2,
    X2 < X3,
    Z  =  (X2 + X3).
    
contas_P0(X1, _, _, Z) =>
   Z = X1.    
\end{lstlisting}
    \end{block}

        
\end{frame}

\begin{frame}[fragile]

\begin{block}{Exemplo de Funções}
     
\begin{lstlisting}[frame=single]
contas_F0(X1, X2, X3) = Z, (number(X1), 
                           number(X2), 
                           number(X3)) =>
    if (X1 < X2 && X2 < X3) then
    Z  =  (X2 + X3)
    else
    Z  =  X1
    end.
\end{lstlisting}
        
 \end{block}

\textcolor{red}{\textit{Aperitivo} à próxima seção: condicionais e laços!}
    
\end{frame}    
\begin{frame}[fragile]
   
\begin{block}{Mais Exemplos (Fatos e Regras)}
    
\begin{lstlisting}[frame=single]
index(-,-) (+,-) (-,+)
pai(salomao, rogerio).
pai(salomao, fabio).
pai(rogerio, miguel).
pai(rogerio, henrique).

avo(X,Y) ?=> pai(X,Z), pai(Z,Y).
irmao(X,Y) ?=> pai(Z,X), pai(Z,Y).
tio(X,Y) ?=> pai(Z,Y), irmao(X,Z).
\end{lstlisting}
    
 \end{block}
    
\end{frame}    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    
\begin{block}{Exemplos de Funções -- Equivalentes}
    
\begin{lstlisting}[frame=single]
eleva_cubo(1) = 1.
eleva_cubo(X) = X**3.
eleva_cubo(X) = X*X*X.
eleva_cubo(X) = X1 => X1 = X**3.
eleva_cubo(X) = X1 => X1 = X*X*X.
\end{lstlisting}
        
\end{block}
    
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Reflexões}

\begin{itemize}

  \item Esta seção trata dos elementos do Picat: cláusulas
 
 \pause 
  \item Predicados ou cláusulas, que são
  de 2 tipos: \textbf{regras predicativas} ou \textbf{funções}

    \pause
  \item \textit{Regras} é um nome genérico a predicados ou cláusulas e funções
    \pause
  \item \textit{Regras} sem corpo são conhecidas como verdades e chamadas de \textbf{fatos}\\
Uso obrigatório do meta-predicado:  \textit{index}
  
   \pause
  \item Lembrando ainda que funções retornam um único valor
  
%   \pause
%  \item Mãos à obra!
\end{itemize}

\end{frame}
